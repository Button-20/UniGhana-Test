{"ast":null,"code":"/**\n * @license Angular v15.1.1\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { computeMsgId } from '@angular/compiler';\nexport { computeMsgId as ɵcomputeMsgId } from '@angular/compiler';\n\n/**\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\n * A block can indicate metadata about the message or specify a name of a placeholder for a\n * substitution expressions.\n *\n * For example:\n *\n * ```ts\n * $localize`Hello, ${title}:title:!`;\n * $localize`:meaning|description@@id:source message text`;\n * ```\n */\nconst BLOCK_MARKER$1 = ':';\n/**\n * The marker used to separate a message's \"meaning\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:correct|Indicates that the user got the answer correct: Right!`;\n * $localize `:movement|Button label for moving to the right: Right!`;\n * ```\n */\nconst MEANING_SEPARATOR = '|';\n/**\n * The marker used to separate a message's custom \"id\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:A welcome message on the home page@@myApp-homepage-welcome: Welcome!`;\n * ```\n */\nconst ID_SEPARATOR = '@@';\n/**\n * The marker used to separate legacy message ids from the rest of a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:@@custom-id␟2df64767cd895a8fabe3e18b94b5b6b6f9e2e3f0: Welcome!`;\n * ```\n *\n * Note that this character is the \"symbol for the unit separator\" (␟) not the \"unit separator\n * character\" itself, since that has no visual representation. See https://graphemica.com/%E2%90%9F.\n *\n * Here is some background for the original \"unit separator character\":\n * https://stackoverflow.com/questions/8695118/whats-the-file-group-record-unit-separator-control-characters-and-its-usage\n */\nconst LEGACY_ID_INDICATOR = '\\u241F';\n\n/**\n * Parse a `$localize` tagged string into a structure that can be used for translation or\n * extraction.\n *\n * See `ParsedMessage` for an example.\n */\nfunction parseMessage(messageParts, expressions, location, messagePartLocations, expressionLocations = []) {\n  const substitutions = {};\n  const substitutionLocations = {};\n  const associatedMessageIds = {};\n  const metadata = parseMetadata(messageParts[0], messageParts.raw[0]);\n  const cleanedMessageParts = [metadata.text];\n  const placeholderNames = [];\n  let messageString = metadata.text;\n  for (let i = 1; i < messageParts.length; i++) {\n    const {\n      messagePart,\n      placeholderName = computePlaceholderName(i),\n      associatedMessageId\n    } = parsePlaceholder(messageParts[i], messageParts.raw[i]);\n    messageString += `{$${placeholderName}}${messagePart}`;\n    if (expressions !== undefined) {\n      substitutions[placeholderName] = expressions[i - 1];\n      substitutionLocations[placeholderName] = expressionLocations[i - 1];\n    }\n    placeholderNames.push(placeholderName);\n    if (associatedMessageId !== undefined) {\n      associatedMessageIds[placeholderName] = associatedMessageId;\n    }\n    cleanedMessageParts.push(messagePart);\n  }\n  const messageId = metadata.customId || computeMsgId(messageString, metadata.meaning || '');\n  const legacyIds = metadata.legacyIds ? metadata.legacyIds.filter(id => id !== messageId) : [];\n  return {\n    id: messageId,\n    legacyIds,\n    substitutions,\n    substitutionLocations,\n    text: messageString,\n    customId: metadata.customId,\n    meaning: metadata.meaning || '',\n    description: metadata.description || '',\n    messageParts: cleanedMessageParts,\n    messagePartLocations,\n    placeholderNames,\n    associatedMessageIds,\n    location\n  };\n}\n/**\n * Parse the given message part (`cooked` + `raw`) to extract the message metadata from the text.\n *\n * If the message part has a metadata block this function will extract the `meaning`,\n * `description`, `customId` and `legacyId` (if provided) from the block. These metadata properties\n * are serialized in the string delimited by `|`, `@@` and `␟` respectively.\n *\n * (Note that `␟` is the `LEGACY_ID_INDICATOR` - see `constants.ts`.)\n *\n * For example:\n *\n * ```ts\n * `:meaning|description@@custom-id:`\n * `:meaning|@@custom-id:`\n * `:meaning|description:`\n * `:description@@custom-id:`\n * `:meaning|:`\n * `:description:`\n * `:@@custom-id:`\n * `:meaning|description@@custom-id␟legacy-id-1␟legacy-id-2:`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing any metadata that was parsed from the message part.\n */\nfunction parseMetadata(cooked, raw) {\n  const {\n    text: messageString,\n    block\n  } = splitBlock(cooked, raw);\n  if (block === undefined) {\n    return {\n      text: messageString\n    };\n  } else {\n    const [meaningDescAndId, ...legacyIds] = block.split(LEGACY_ID_INDICATOR);\n    const [meaningAndDesc, customId] = meaningDescAndId.split(ID_SEPARATOR, 2);\n    let [meaning, description] = meaningAndDesc.split(MEANING_SEPARATOR, 2);\n    if (description === undefined) {\n      description = meaning;\n      meaning = undefined;\n    }\n    if (description === '') {\n      description = undefined;\n    }\n    return {\n      text: messageString,\n      meaning,\n      description,\n      customId,\n      legacyIds\n    };\n  }\n}\n/**\n * Parse the given message part (`cooked` + `raw`) to extract any placeholder metadata from the\n * text.\n *\n * If the message part has a metadata block this function will extract the `placeholderName` and\n * `associatedMessageId` (if provided) from the block.\n *\n * These metadata properties are serialized in the string delimited by `@@`.\n *\n * For example:\n *\n * ```ts\n * `:placeholder-name@@associated-id:`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing the metadata (`placeholderName` and `associatedMessageId`) of the\n *     preceding placeholder, along with the static text that follows.\n */\nfunction parsePlaceholder(cooked, raw) {\n  const {\n    text: messagePart,\n    block\n  } = splitBlock(cooked, raw);\n  if (block === undefined) {\n    return {\n      messagePart\n    };\n  } else {\n    const [placeholderName, associatedMessageId] = block.split(ID_SEPARATOR);\n    return {\n      messagePart,\n      placeholderName,\n      associatedMessageId\n    };\n  }\n}\n/**\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\n * rest of the text of the message part.\n *\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\n * start and end of the block.\n *\n * If the block is in the first message part then it will be metadata about the whole message:\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\n * substitution: placeholder name.\n *\n * Since blocks are optional, it is possible that the content of a message block actually starts\n * with a block marker. In this case the marker must be escaped `\\:`.\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\n * exists.\n * @throws an error if the `block` is unterminated\n */\nfunction splitBlock(cooked, raw) {\n  if (raw.charAt(0) !== BLOCK_MARKER$1) {\n    return {\n      text: cooked\n    };\n  } else {\n    const endOfBlock = findEndOfBlock(cooked, raw);\n    return {\n      block: cooked.substring(1, endOfBlock),\n      text: cooked.substring(endOfBlock + 1)\n    };\n  }\n}\nfunction computePlaceholderName(index) {\n  return index === 1 ? 'PH' : `PH_${index - 1}`;\n}\n/**\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\n *\n * @param cooked The cooked string (where escaped chars have been processed)\n * @param raw The raw string (where escape sequences are still in place)\n *\n * @returns the index of the end of block marker\n * @throws an error if the block is unterminated\n */\nfunction findEndOfBlock(cooked, raw) {\n  for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\n    if (raw[rawIndex] === '\\\\') {\n      rawIndex++;\n    } else if (cooked[cookedIndex] === BLOCK_MARKER$1) {\n      return cookedIndex;\n    }\n  }\n  throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\n}\nclass MissingTranslationError extends Error {\n  constructor(parsedMessage) {\n    super(`No translation found for ${describeMessage(parsedMessage)}.`);\n    this.parsedMessage = parsedMessage;\n    this.type = 'MissingTranslationError';\n  }\n}\nfunction isMissingTranslationError(e) {\n  return e.type === 'MissingTranslationError';\n}\n/**\n * Translate the text of the `$localize` tagged-string (i.e. `messageParts` and\n * `substitutions`) using the given `translations`.\n *\n * The tagged-string is parsed to extract its `messageId` which is used to find an appropriate\n * `ParsedTranslation`. If this doesn't match and there are legacy ids then try matching a\n * translation using those.\n *\n * If one is found then it is used to translate the message into a new set of `messageParts` and\n * `substitutions`.\n * The translation may reorder (or remove) substitutions as appropriate.\n *\n * If there is no translation with a matching message id then an error is thrown.\n * If a translation contains a placeholder that is not found in the message being translated then an\n * error is thrown.\n */\nfunction translate$1(translations, messageParts, substitutions) {\n  const message = parseMessage(messageParts, substitutions);\n  // Look up the translation using the messageId, and then the legacyId if available.\n  let translation = translations[message.id];\n  // If the messageId did not match a translation, try matching the legacy ids instead\n  if (message.legacyIds !== undefined) {\n    for (let i = 0; i < message.legacyIds.length && translation === undefined; i++) {\n      translation = translations[message.legacyIds[i]];\n    }\n  }\n  if (translation === undefined) {\n    throw new MissingTranslationError(message);\n  }\n  return [translation.messageParts, translation.placeholderNames.map(placeholder => {\n    if (message.substitutions.hasOwnProperty(placeholder)) {\n      return message.substitutions[placeholder];\n    } else {\n      throw new Error(`There is a placeholder name mismatch with the translation provided for the message ${describeMessage(message)}.\\n` + `The translation contains a placeholder with name ${placeholder}, which does not exist in the message.`);\n    }\n  })];\n}\n/**\n * Parse the `messageParts` and `placeholderNames` out of a target `message`.\n *\n * Used by `loadTranslations()` to convert target message strings into a structure that is more\n * appropriate for doing translation.\n *\n * @param message the message to be parsed.\n */\nfunction parseTranslation(messageString) {\n  const parts = messageString.split(/{\\$([^}]*)}/);\n  const messageParts = [parts[0]];\n  const placeholderNames = [];\n  for (let i = 1; i < parts.length - 1; i += 2) {\n    placeholderNames.push(parts[i]);\n    messageParts.push(`${parts[i + 1]}`);\n  }\n  const rawMessageParts = messageParts.map(part => part.charAt(0) === BLOCK_MARKER$1 ? '\\\\' + part : part);\n  return {\n    text: messageString,\n    messageParts: makeTemplateObject(messageParts, rawMessageParts),\n    placeholderNames\n  };\n}\n/**\n * Create a `ParsedTranslation` from a set of `messageParts` and `placeholderNames`.\n *\n * @param messageParts The message parts to appear in the ParsedTranslation.\n * @param placeholderNames The names of the placeholders to intersperse between the `messageParts`.\n */\nfunction makeParsedTranslation(messageParts, placeholderNames = []) {\n  let messageString = messageParts[0];\n  for (let i = 0; i < placeholderNames.length; i++) {\n    messageString += `{$${placeholderNames[i]}}${messageParts[i + 1]}`;\n  }\n  return {\n    text: messageString,\n    messageParts: makeTemplateObject(messageParts, messageParts),\n    placeholderNames\n  };\n}\n/**\n * Create the specialized array that is passed to tagged-string tag functions.\n *\n * @param cooked The message parts with their escape codes processed.\n * @param raw The message parts with their escaped codes as-is.\n */\nfunction makeTemplateObject(cooked, raw) {\n  Object.defineProperty(cooked, 'raw', {\n    value: raw\n  });\n  return cooked;\n}\nfunction describeMessage(message) {\n  const meaningString = message.meaning && ` - \"${message.meaning}\"`;\n  const legacy = message.legacyIds && message.legacyIds.length > 0 ? ` [${message.legacyIds.map(l => `\"${l}\"`).join(', ')}]` : '';\n  return `\"${message.id}\"${legacy} (\"${message.text}\"${meaningString})`;\n}\n\n/**\n * Load translations for use by `$localize`, if doing runtime translation.\n *\n * If the `$localize` tagged strings are not going to be replaced at compiled time, it is possible\n * to load a set of translations that will be applied to the `$localize` tagged strings at runtime,\n * in the browser.\n *\n * Loading a new translation will overwrite a previous translation if it has the same `MessageId`.\n *\n * Note that `$localize` messages are only processed once, when the tagged string is first\n * encountered, and does not provide dynamic language changing without refreshing the browser.\n * Loading new translations later in the application life-cycle will not change the translated text\n * of messages that have already been translated.\n *\n * The message IDs and translations are in the same format as that rendered to \"simple JSON\"\n * translation files when extracting messages. In particular, placeholders in messages are rendered\n * using the `{$PLACEHOLDER_NAME}` syntax. For example the message from the following template:\n *\n * ```html\n * <div i18n>pre<span>inner-pre<b>bold</b>inner-post</span>post</div>\n * ```\n *\n * would have the following form in the `translations` map:\n *\n * ```ts\n * {\n *   \"2932901491976224757\":\n *      \"pre{$START_TAG_SPAN}inner-pre{$START_BOLD_TEXT}bold{$CLOSE_BOLD_TEXT}inner-post{$CLOSE_TAG_SPAN}post\"\n * }\n * ```\n *\n * @param translations A map from message ID to translated message.\n *\n * These messages are processed and added to a lookup based on their `MessageId`.\n *\n * @see `clearTranslations()` for removing translations loaded using this function.\n * @see `$localize` for tagging messages as needing to be translated.\n * @publicApi\n */\nfunction loadTranslations(translations) {\n  // Ensure the translate function exists\n  if (!$localize.translate) {\n    $localize.translate = translate;\n  }\n  if (!$localize.TRANSLATIONS) {\n    $localize.TRANSLATIONS = {};\n  }\n  Object.keys(translations).forEach(key => {\n    $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);\n  });\n}\n/**\n * Remove all translations for `$localize`, if doing runtime translation.\n *\n * All translations that had been loading into memory using `loadTranslations()` will be removed.\n *\n * @see `loadTranslations()` for loading translations at runtime.\n * @see `$localize` for tagging messages as needing to be translated.\n *\n * @publicApi\n */\nfunction clearTranslations() {\n  $localize.translate = undefined;\n  $localize.TRANSLATIONS = {};\n}\n/**\n * Translate the text of the given message, using the loaded translations.\n *\n * This function may reorder (or remove) substitutions as indicated in the matching translation.\n */\nfunction translate(messageParts, substitutions) {\n  try {\n    return translate$1($localize.TRANSLATIONS, messageParts, substitutions);\n  } catch (e) {\n    console.warn(e.message);\n    return [messageParts, substitutions];\n  }\n}\n\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global = /* @__PURE__ */(() => typeof globalThis !== 'undefined' && globalThis || typeof global !== 'undefined' && global || typeof window !== 'undefined' && window || typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self)();\n\n/**\n * Tag a template literal string for localization.\n *\n * For example:\n *\n * ```ts\n * $localize `some string to localize`\n * ```\n *\n * **Providing meaning, description and id**\n *\n * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n * string by pre-pending it with a colon delimited block of the form:\n *\n * ```ts\n * $localize`:meaning|description@@id:source message text`;\n *\n * $localize`:meaning|:source message text`;\n * $localize`:description:source message text`;\n * $localize`:@@id:source message text`;\n * ```\n *\n * This format is the same as that used for `i18n` markers in Angular templates. See the\n * [Angular i18n guide](guide/i18n-common-prepare#mark-text-in-component-template).\n *\n * **Naming placeholders**\n *\n * If the template literal string contains expressions, then the expressions will be automatically\n * associated with placeholder names for you.\n *\n * For example:\n *\n * ```ts\n * $localize `Hi ${name}! There are ${items.length} items.`;\n * ```\n *\n * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\n *\n * The recommended practice is to name the placeholder associated with each expression though.\n *\n * Do this by providing the placeholder name wrapped in `:` characters directly after the\n * expression. These placeholder names are stripped out of the rendered localized string.\n *\n * For example, to name the `items.length` expression placeholder `itemCount` you write:\n *\n * ```ts\n * $localize `There are ${items.length}:itemCount: items`;\n * ```\n *\n * **Escaping colon markers**\n *\n * If you need to use a `:` character directly at the start of a tagged string that has no\n * metadata block, or directly after a substitution expression that has no name you must escape\n * the `:` by preceding it with a backslash:\n *\n * For example:\n *\n * ```ts\n * // message has a metadata block so no need to escape colon\n * $localize `:some description::this message starts with a colon (:)`;\n * // no metadata block so the colon must be escaped\n * $localize `\\:this message starts with a colon (:)`;\n * ```\n *\n * ```ts\n * // named substitution so no need to escape colon\n * $localize `${label}:label:: ${}`\n * // anonymous substitution so colon must be escaped\n * $localize `${label}\\: ${}`\n * ```\n *\n * **Processing localized strings:**\n *\n * There are three scenarios:\n *\n * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n * transpiler, removing the tag and replacing the template literal string with a translated\n * literal string from a collection of translations provided to the transpilation tool.\n *\n * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n * reorders the parts (static strings and expressions) of the template literal string with strings\n * from a collection of translations loaded at run-time.\n *\n * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n * the original template literal string without applying any translations to the parts. This\n * version is used during development or where there is no need to translate the localized\n * template literals.\n *\n * @param messageParts a collection of the static parts of the template string.\n * @param expressions a collection of the values of each placeholder in the template string.\n * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n *\n * @globalApi\n * @publicApi\n */\nconst $localize$1 = function (messageParts, ...expressions) {\n  if ($localize$1.translate) {\n    // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n    const translation = $localize$1.translate(messageParts, expressions);\n    messageParts = translation[0];\n    expressions = translation[1];\n  }\n  let message = stripBlock(messageParts[0], messageParts.raw[0]);\n  for (let i = 1; i < messageParts.length; i++) {\n    message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);\n  }\n  return message;\n};\nconst BLOCK_MARKER = ':';\n/**\n * Strip a delimited \"block\" from the start of the `messagePart`, if it is found.\n *\n * If a marker character (:) actually appears in the content at the start of a tagged string or\n * after a substitution expression, where a block has not been provided the character must be\n * escaped with a backslash, `\\:`. This function checks for this by looking at the `raw`\n * messagePart, which should still contain the backslash.\n *\n * @param messagePart The cooked message part to process.\n * @param rawMessagePart The raw message part to check.\n * @returns the message part with the placeholder name stripped, if found.\n * @throws an error if the block is unterminated\n */\nfunction stripBlock(messagePart, rawMessagePart) {\n  return rawMessagePart.charAt(0) === BLOCK_MARKER ? messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1) : messagePart;\n}\n\n// This file exports all the `utils` as private exports so that other parts of `@angular/localize`\n\n// This file contains the public API of the `@angular/localize` entry-point\n\n// DO NOT ADD public exports to this file.\n\nexport { clearTranslations, loadTranslations, $localize$1 as ɵ$localize, MissingTranslationError as ɵMissingTranslationError, _global as ɵ_global, findEndOfBlock as ɵfindEndOfBlock, isMissingTranslationError as ɵisMissingTranslationError, makeParsedTranslation as ɵmakeParsedTranslation, makeTemplateObject as ɵmakeTemplateObject, parseMessage as ɵparseMessage, parseMetadata as ɵparseMetadata, parseTranslation as ɵparseTranslation, splitBlock as ɵsplitBlock, translate$1 as ɵtranslate };","map":{"version":3,"names":["computeMsgId","ɵcomputeMsgId","BLOCK_MARKER$1","MEANING_SEPARATOR","ID_SEPARATOR","LEGACY_ID_INDICATOR","parseMessage","messageParts","expressions","location","messagePartLocations","expressionLocations","substitutions","substitutionLocations","associatedMessageIds","metadata","parseMetadata","raw","cleanedMessageParts","text","placeholderNames","messageString","i","length","messagePart","placeholderName","computePlaceholderName","associatedMessageId","parsePlaceholder","undefined","push","messageId","customId","meaning","legacyIds","filter","id","description","cooked","block","splitBlock","meaningDescAndId","split","meaningAndDesc","charAt","endOfBlock","findEndOfBlock","substring","index","cookedIndex","rawIndex","Error","MissingTranslationError","constructor","parsedMessage","describeMessage","type","isMissingTranslationError","e","translate$1","translations","message","translation","map","placeholder","hasOwnProperty","parseTranslation","parts","rawMessageParts","part","makeTemplateObject","makeParsedTranslation","Object","defineProperty","value","meaningString","legacy","l","join","loadTranslations","$localize","translate","TRANSLATIONS","keys","forEach","key","clearTranslations","console","warn","_global","globalThis","global","window","self","WorkerGlobalScope","$localize$1","stripBlock","BLOCK_MARKER","rawMessagePart","ɵ$localize","ɵMissingTranslationError","ɵ_global","ɵfindEndOfBlock","ɵisMissingTranslationError","ɵmakeParsedTranslation","ɵmakeTemplateObject","ɵparseMessage","ɵparseMetadata","ɵparseTranslation","ɵsplitBlock","ɵtranslate"],"sources":["C:/Users/SoundIt/Desktop/Development/unighana-test/frontend/node_modules/@angular/localize/fesm2020/localize.mjs"],"sourcesContent":["/**\n * @license Angular v15.1.1\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { computeMsgId } from '@angular/compiler';\nexport { computeMsgId as ɵcomputeMsgId } from '@angular/compiler';\n\n/**\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\n * A block can indicate metadata about the message or specify a name of a placeholder for a\n * substitution expressions.\n *\n * For example:\n *\n * ```ts\n * $localize`Hello, ${title}:title:!`;\n * $localize`:meaning|description@@id:source message text`;\n * ```\n */\nconst BLOCK_MARKER$1 = ':';\n/**\n * The marker used to separate a message's \"meaning\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:correct|Indicates that the user got the answer correct: Right!`;\n * $localize `:movement|Button label for moving to the right: Right!`;\n * ```\n */\nconst MEANING_SEPARATOR = '|';\n/**\n * The marker used to separate a message's custom \"id\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:A welcome message on the home page@@myApp-homepage-welcome: Welcome!`;\n * ```\n */\nconst ID_SEPARATOR = '@@';\n/**\n * The marker used to separate legacy message ids from the rest of a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:@@custom-id␟2df64767cd895a8fabe3e18b94b5b6b6f9e2e3f0: Welcome!`;\n * ```\n *\n * Note that this character is the \"symbol for the unit separator\" (␟) not the \"unit separator\n * character\" itself, since that has no visual representation. See https://graphemica.com/%E2%90%9F.\n *\n * Here is some background for the original \"unit separator character\":\n * https://stackoverflow.com/questions/8695118/whats-the-file-group-record-unit-separator-control-characters-and-its-usage\n */\nconst LEGACY_ID_INDICATOR = '\\u241F';\n\n/**\n * Parse a `$localize` tagged string into a structure that can be used for translation or\n * extraction.\n *\n * See `ParsedMessage` for an example.\n */\nfunction parseMessage(messageParts, expressions, location, messagePartLocations, expressionLocations = []) {\n    const substitutions = {};\n    const substitutionLocations = {};\n    const associatedMessageIds = {};\n    const metadata = parseMetadata(messageParts[0], messageParts.raw[0]);\n    const cleanedMessageParts = [metadata.text];\n    const placeholderNames = [];\n    let messageString = metadata.text;\n    for (let i = 1; i < messageParts.length; i++) {\n        const { messagePart, placeholderName = computePlaceholderName(i), associatedMessageId } = parsePlaceholder(messageParts[i], messageParts.raw[i]);\n        messageString += `{$${placeholderName}}${messagePart}`;\n        if (expressions !== undefined) {\n            substitutions[placeholderName] = expressions[i - 1];\n            substitutionLocations[placeholderName] = expressionLocations[i - 1];\n        }\n        placeholderNames.push(placeholderName);\n        if (associatedMessageId !== undefined) {\n            associatedMessageIds[placeholderName] = associatedMessageId;\n        }\n        cleanedMessageParts.push(messagePart);\n    }\n    const messageId = metadata.customId || computeMsgId(messageString, metadata.meaning || '');\n    const legacyIds = metadata.legacyIds ? metadata.legacyIds.filter(id => id !== messageId) : [];\n    return {\n        id: messageId,\n        legacyIds,\n        substitutions,\n        substitutionLocations,\n        text: messageString,\n        customId: metadata.customId,\n        meaning: metadata.meaning || '',\n        description: metadata.description || '',\n        messageParts: cleanedMessageParts,\n        messagePartLocations,\n        placeholderNames,\n        associatedMessageIds,\n        location,\n    };\n}\n/**\n * Parse the given message part (`cooked` + `raw`) to extract the message metadata from the text.\n *\n * If the message part has a metadata block this function will extract the `meaning`,\n * `description`, `customId` and `legacyId` (if provided) from the block. These metadata properties\n * are serialized in the string delimited by `|`, `@@` and `␟` respectively.\n *\n * (Note that `␟` is the `LEGACY_ID_INDICATOR` - see `constants.ts`.)\n *\n * For example:\n *\n * ```ts\n * `:meaning|description@@custom-id:`\n * `:meaning|@@custom-id:`\n * `:meaning|description:`\n * `:description@@custom-id:`\n * `:meaning|:`\n * `:description:`\n * `:@@custom-id:`\n * `:meaning|description@@custom-id␟legacy-id-1␟legacy-id-2:`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing any metadata that was parsed from the message part.\n */\nfunction parseMetadata(cooked, raw) {\n    const { text: messageString, block } = splitBlock(cooked, raw);\n    if (block === undefined) {\n        return { text: messageString };\n    }\n    else {\n        const [meaningDescAndId, ...legacyIds] = block.split(LEGACY_ID_INDICATOR);\n        const [meaningAndDesc, customId] = meaningDescAndId.split(ID_SEPARATOR, 2);\n        let [meaning, description] = meaningAndDesc.split(MEANING_SEPARATOR, 2);\n        if (description === undefined) {\n            description = meaning;\n            meaning = undefined;\n        }\n        if (description === '') {\n            description = undefined;\n        }\n        return { text: messageString, meaning, description, customId, legacyIds };\n    }\n}\n/**\n * Parse the given message part (`cooked` + `raw`) to extract any placeholder metadata from the\n * text.\n *\n * If the message part has a metadata block this function will extract the `placeholderName` and\n * `associatedMessageId` (if provided) from the block.\n *\n * These metadata properties are serialized in the string delimited by `@@`.\n *\n * For example:\n *\n * ```ts\n * `:placeholder-name@@associated-id:`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing the metadata (`placeholderName` and `associatedMessageId`) of the\n *     preceding placeholder, along with the static text that follows.\n */\nfunction parsePlaceholder(cooked, raw) {\n    const { text: messagePart, block } = splitBlock(cooked, raw);\n    if (block === undefined) {\n        return { messagePart };\n    }\n    else {\n        const [placeholderName, associatedMessageId] = block.split(ID_SEPARATOR);\n        return { messagePart, placeholderName, associatedMessageId };\n    }\n}\n/**\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\n * rest of the text of the message part.\n *\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\n * start and end of the block.\n *\n * If the block is in the first message part then it will be metadata about the whole message:\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\n * substitution: placeholder name.\n *\n * Since blocks are optional, it is possible that the content of a message block actually starts\n * with a block marker. In this case the marker must be escaped `\\:`.\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\n * exists.\n * @throws an error if the `block` is unterminated\n */\nfunction splitBlock(cooked, raw) {\n    if (raw.charAt(0) !== BLOCK_MARKER$1) {\n        return { text: cooked };\n    }\n    else {\n        const endOfBlock = findEndOfBlock(cooked, raw);\n        return {\n            block: cooked.substring(1, endOfBlock),\n            text: cooked.substring(endOfBlock + 1),\n        };\n    }\n}\nfunction computePlaceholderName(index) {\n    return index === 1 ? 'PH' : `PH_${index - 1}`;\n}\n/**\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\n *\n * @param cooked The cooked string (where escaped chars have been processed)\n * @param raw The raw string (where escape sequences are still in place)\n *\n * @returns the index of the end of block marker\n * @throws an error if the block is unterminated\n */\nfunction findEndOfBlock(cooked, raw) {\n    for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\n        if (raw[rawIndex] === '\\\\') {\n            rawIndex++;\n        }\n        else if (cooked[cookedIndex] === BLOCK_MARKER$1) {\n            return cookedIndex;\n        }\n    }\n    throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\n}\n\nclass MissingTranslationError extends Error {\n    constructor(parsedMessage) {\n        super(`No translation found for ${describeMessage(parsedMessage)}.`);\n        this.parsedMessage = parsedMessage;\n        this.type = 'MissingTranslationError';\n    }\n}\nfunction isMissingTranslationError(e) {\n    return e.type === 'MissingTranslationError';\n}\n/**\n * Translate the text of the `$localize` tagged-string (i.e. `messageParts` and\n * `substitutions`) using the given `translations`.\n *\n * The tagged-string is parsed to extract its `messageId` which is used to find an appropriate\n * `ParsedTranslation`. If this doesn't match and there are legacy ids then try matching a\n * translation using those.\n *\n * If one is found then it is used to translate the message into a new set of `messageParts` and\n * `substitutions`.\n * The translation may reorder (or remove) substitutions as appropriate.\n *\n * If there is no translation with a matching message id then an error is thrown.\n * If a translation contains a placeholder that is not found in the message being translated then an\n * error is thrown.\n */\nfunction translate$1(translations, messageParts, substitutions) {\n    const message = parseMessage(messageParts, substitutions);\n    // Look up the translation using the messageId, and then the legacyId if available.\n    let translation = translations[message.id];\n    // If the messageId did not match a translation, try matching the legacy ids instead\n    if (message.legacyIds !== undefined) {\n        for (let i = 0; i < message.legacyIds.length && translation === undefined; i++) {\n            translation = translations[message.legacyIds[i]];\n        }\n    }\n    if (translation === undefined) {\n        throw new MissingTranslationError(message);\n    }\n    return [\n        translation.messageParts, translation.placeholderNames.map(placeholder => {\n            if (message.substitutions.hasOwnProperty(placeholder)) {\n                return message.substitutions[placeholder];\n            }\n            else {\n                throw new Error(`There is a placeholder name mismatch with the translation provided for the message ${describeMessage(message)}.\\n` +\n                    `The translation contains a placeholder with name ${placeholder}, which does not exist in the message.`);\n            }\n        })\n    ];\n}\n/**\n * Parse the `messageParts` and `placeholderNames` out of a target `message`.\n *\n * Used by `loadTranslations()` to convert target message strings into a structure that is more\n * appropriate for doing translation.\n *\n * @param message the message to be parsed.\n */\nfunction parseTranslation(messageString) {\n    const parts = messageString.split(/{\\$([^}]*)}/);\n    const messageParts = [parts[0]];\n    const placeholderNames = [];\n    for (let i = 1; i < parts.length - 1; i += 2) {\n        placeholderNames.push(parts[i]);\n        messageParts.push(`${parts[i + 1]}`);\n    }\n    const rawMessageParts = messageParts.map(part => part.charAt(0) === BLOCK_MARKER$1 ? '\\\\' + part : part);\n    return {\n        text: messageString,\n        messageParts: makeTemplateObject(messageParts, rawMessageParts),\n        placeholderNames,\n    };\n}\n/**\n * Create a `ParsedTranslation` from a set of `messageParts` and `placeholderNames`.\n *\n * @param messageParts The message parts to appear in the ParsedTranslation.\n * @param placeholderNames The names of the placeholders to intersperse between the `messageParts`.\n */\nfunction makeParsedTranslation(messageParts, placeholderNames = []) {\n    let messageString = messageParts[0];\n    for (let i = 0; i < placeholderNames.length; i++) {\n        messageString += `{$${placeholderNames[i]}}${messageParts[i + 1]}`;\n    }\n    return {\n        text: messageString,\n        messageParts: makeTemplateObject(messageParts, messageParts),\n        placeholderNames\n    };\n}\n/**\n * Create the specialized array that is passed to tagged-string tag functions.\n *\n * @param cooked The message parts with their escape codes processed.\n * @param raw The message parts with their escaped codes as-is.\n */\nfunction makeTemplateObject(cooked, raw) {\n    Object.defineProperty(cooked, 'raw', { value: raw });\n    return cooked;\n}\nfunction describeMessage(message) {\n    const meaningString = message.meaning && ` - \"${message.meaning}\"`;\n    const legacy = message.legacyIds && message.legacyIds.length > 0 ?\n        ` [${message.legacyIds.map(l => `\"${l}\"`).join(', ')}]` :\n        '';\n    return `\"${message.id}\"${legacy} (\"${message.text}\"${meaningString})`;\n}\n\n/**\n * Load translations for use by `$localize`, if doing runtime translation.\n *\n * If the `$localize` tagged strings are not going to be replaced at compiled time, it is possible\n * to load a set of translations that will be applied to the `$localize` tagged strings at runtime,\n * in the browser.\n *\n * Loading a new translation will overwrite a previous translation if it has the same `MessageId`.\n *\n * Note that `$localize` messages are only processed once, when the tagged string is first\n * encountered, and does not provide dynamic language changing without refreshing the browser.\n * Loading new translations later in the application life-cycle will not change the translated text\n * of messages that have already been translated.\n *\n * The message IDs and translations are in the same format as that rendered to \"simple JSON\"\n * translation files when extracting messages. In particular, placeholders in messages are rendered\n * using the `{$PLACEHOLDER_NAME}` syntax. For example the message from the following template:\n *\n * ```html\n * <div i18n>pre<span>inner-pre<b>bold</b>inner-post</span>post</div>\n * ```\n *\n * would have the following form in the `translations` map:\n *\n * ```ts\n * {\n *   \"2932901491976224757\":\n *      \"pre{$START_TAG_SPAN}inner-pre{$START_BOLD_TEXT}bold{$CLOSE_BOLD_TEXT}inner-post{$CLOSE_TAG_SPAN}post\"\n * }\n * ```\n *\n * @param translations A map from message ID to translated message.\n *\n * These messages are processed and added to a lookup based on their `MessageId`.\n *\n * @see `clearTranslations()` for removing translations loaded using this function.\n * @see `$localize` for tagging messages as needing to be translated.\n * @publicApi\n */\nfunction loadTranslations(translations) {\n    // Ensure the translate function exists\n    if (!$localize.translate) {\n        $localize.translate = translate;\n    }\n    if (!$localize.TRANSLATIONS) {\n        $localize.TRANSLATIONS = {};\n    }\n    Object.keys(translations).forEach(key => {\n        $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);\n    });\n}\n/**\n * Remove all translations for `$localize`, if doing runtime translation.\n *\n * All translations that had been loading into memory using `loadTranslations()` will be removed.\n *\n * @see `loadTranslations()` for loading translations at runtime.\n * @see `$localize` for tagging messages as needing to be translated.\n *\n * @publicApi\n */\nfunction clearTranslations() {\n    $localize.translate = undefined;\n    $localize.TRANSLATIONS = {};\n}\n/**\n * Translate the text of the given message, using the loaded translations.\n *\n * This function may reorder (or remove) substitutions as indicated in the matching translation.\n */\nfunction translate(messageParts, substitutions) {\n    try {\n        return translate$1($localize.TRANSLATIONS, messageParts, substitutions);\n    }\n    catch (e) {\n        console.warn(e.message);\n        return [messageParts, substitutions];\n    }\n}\n\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global = ( /* @__PURE__ */(() => (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof global !== 'undefined' && global) || (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self))());\n\n/**\n * Tag a template literal string for localization.\n *\n * For example:\n *\n * ```ts\n * $localize `some string to localize`\n * ```\n *\n * **Providing meaning, description and id**\n *\n * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n * string by pre-pending it with a colon delimited block of the form:\n *\n * ```ts\n * $localize`:meaning|description@@id:source message text`;\n *\n * $localize`:meaning|:source message text`;\n * $localize`:description:source message text`;\n * $localize`:@@id:source message text`;\n * ```\n *\n * This format is the same as that used for `i18n` markers in Angular templates. See the\n * [Angular i18n guide](guide/i18n-common-prepare#mark-text-in-component-template).\n *\n * **Naming placeholders**\n *\n * If the template literal string contains expressions, then the expressions will be automatically\n * associated with placeholder names for you.\n *\n * For example:\n *\n * ```ts\n * $localize `Hi ${name}! There are ${items.length} items.`;\n * ```\n *\n * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\n *\n * The recommended practice is to name the placeholder associated with each expression though.\n *\n * Do this by providing the placeholder name wrapped in `:` characters directly after the\n * expression. These placeholder names are stripped out of the rendered localized string.\n *\n * For example, to name the `items.length` expression placeholder `itemCount` you write:\n *\n * ```ts\n * $localize `There are ${items.length}:itemCount: items`;\n * ```\n *\n * **Escaping colon markers**\n *\n * If you need to use a `:` character directly at the start of a tagged string that has no\n * metadata block, or directly after a substitution expression that has no name you must escape\n * the `:` by preceding it with a backslash:\n *\n * For example:\n *\n * ```ts\n * // message has a metadata block so no need to escape colon\n * $localize `:some description::this message starts with a colon (:)`;\n * // no metadata block so the colon must be escaped\n * $localize `\\:this message starts with a colon (:)`;\n * ```\n *\n * ```ts\n * // named substitution so no need to escape colon\n * $localize `${label}:label:: ${}`\n * // anonymous substitution so colon must be escaped\n * $localize `${label}\\: ${}`\n * ```\n *\n * **Processing localized strings:**\n *\n * There are three scenarios:\n *\n * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n * transpiler, removing the tag and replacing the template literal string with a translated\n * literal string from a collection of translations provided to the transpilation tool.\n *\n * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n * reorders the parts (static strings and expressions) of the template literal string with strings\n * from a collection of translations loaded at run-time.\n *\n * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n * the original template literal string without applying any translations to the parts. This\n * version is used during development or where there is no need to translate the localized\n * template literals.\n *\n * @param messageParts a collection of the static parts of the template string.\n * @param expressions a collection of the values of each placeholder in the template string.\n * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n *\n * @globalApi\n * @publicApi\n */\nconst $localize$1 = function (messageParts, ...expressions) {\n    if ($localize$1.translate) {\n        // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n        const translation = $localize$1.translate(messageParts, expressions);\n        messageParts = translation[0];\n        expressions = translation[1];\n    }\n    let message = stripBlock(messageParts[0], messageParts.raw[0]);\n    for (let i = 1; i < messageParts.length; i++) {\n        message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);\n    }\n    return message;\n};\nconst BLOCK_MARKER = ':';\n/**\n * Strip a delimited \"block\" from the start of the `messagePart`, if it is found.\n *\n * If a marker character (:) actually appears in the content at the start of a tagged string or\n * after a substitution expression, where a block has not been provided the character must be\n * escaped with a backslash, `\\:`. This function checks for this by looking at the `raw`\n * messagePart, which should still contain the backslash.\n *\n * @param messagePart The cooked message part to process.\n * @param rawMessagePart The raw message part to check.\n * @returns the message part with the placeholder name stripped, if found.\n * @throws an error if the block is unterminated\n */\nfunction stripBlock(messagePart, rawMessagePart) {\n    return rawMessagePart.charAt(0) === BLOCK_MARKER ?\n        messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1) :\n        messagePart;\n}\n\n// This file exports all the `utils` as private exports so that other parts of `@angular/localize`\n\n// This file contains the public API of the `@angular/localize` entry-point\n\n// DO NOT ADD public exports to this file.\n\nexport { clearTranslations, loadTranslations, $localize$1 as ɵ$localize, MissingTranslationError as ɵMissingTranslationError, _global as ɵ_global, findEndOfBlock as ɵfindEndOfBlock, isMissingTranslationError as ɵisMissingTranslationError, makeParsedTranslation as ɵmakeParsedTranslation, makeTemplateObject as ɵmakeTemplateObject, parseMessage as ɵparseMessage, parseMetadata as ɵparseMetadata, parseTranslation as ɵparseTranslation, splitBlock as ɵsplitBlock, translate$1 as ɵtranslate };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,SAASA,YAAY,QAAQ,mBAAmB;AAChD,SAASA,YAAY,IAAIC,aAAa,QAAQ,mBAAmB;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,GAAG,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,GAAG,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAG,IAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,GAAG,QAAQ;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAY,CAACC,YAAY,EAAEC,WAAW,EAAEC,QAAQ,EAAEC,oBAAoB,EAAEC,mBAAmB,GAAG,EAAE,EAAE;EACvG,MAAMC,aAAa,GAAG,CAAC,CAAC;EACxB,MAAMC,qBAAqB,GAAG,CAAC,CAAC;EAChC,MAAMC,oBAAoB,GAAG,CAAC,CAAC;EAC/B,MAAMC,QAAQ,GAAGC,aAAa,CAACT,YAAY,CAAC,CAAC,CAAC,EAAEA,YAAY,CAACU,GAAG,CAAC,CAAC,CAAC,CAAC;EACpE,MAAMC,mBAAmB,GAAG,CAACH,QAAQ,CAACI,IAAI,CAAC;EAC3C,MAAMC,gBAAgB,GAAG,EAAE;EAC3B,IAAIC,aAAa,GAAGN,QAAQ,CAACI,IAAI;EACjC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,YAAY,CAACgB,MAAM,EAAED,CAAC,EAAE,EAAE;IAC1C,MAAM;MAAEE,WAAW;MAAEC,eAAe,GAAGC,sBAAsB,CAACJ,CAAC,CAAC;MAAEK;IAAoB,CAAC,GAAGC,gBAAgB,CAACrB,YAAY,CAACe,CAAC,CAAC,EAAEf,YAAY,CAACU,GAAG,CAACK,CAAC,CAAC,CAAC;IAChJD,aAAa,IAAK,KAAII,eAAgB,IAAGD,WAAY,EAAC;IACtD,IAAIhB,WAAW,KAAKqB,SAAS,EAAE;MAC3BjB,aAAa,CAACa,eAAe,CAAC,GAAGjB,WAAW,CAACc,CAAC,GAAG,CAAC,CAAC;MACnDT,qBAAqB,CAACY,eAAe,CAAC,GAAGd,mBAAmB,CAACW,CAAC,GAAG,CAAC,CAAC;IACvE;IACAF,gBAAgB,CAACU,IAAI,CAACL,eAAe,CAAC;IACtC,IAAIE,mBAAmB,KAAKE,SAAS,EAAE;MACnCf,oBAAoB,CAACW,eAAe,CAAC,GAAGE,mBAAmB;IAC/D;IACAT,mBAAmB,CAACY,IAAI,CAACN,WAAW,CAAC;EACzC;EACA,MAAMO,SAAS,GAAGhB,QAAQ,CAACiB,QAAQ,IAAIhC,YAAY,CAACqB,aAAa,EAAEN,QAAQ,CAACkB,OAAO,IAAI,EAAE,CAAC;EAC1F,MAAMC,SAAS,GAAGnB,QAAQ,CAACmB,SAAS,GAAGnB,QAAQ,CAACmB,SAAS,CAACC,MAAM,CAACC,EAAE,IAAIA,EAAE,KAAKL,SAAS,CAAC,GAAG,EAAE;EAC7F,OAAO;IACHK,EAAE,EAAEL,SAAS;IACbG,SAAS;IACTtB,aAAa;IACbC,qBAAqB;IACrBM,IAAI,EAAEE,aAAa;IACnBW,QAAQ,EAAEjB,QAAQ,CAACiB,QAAQ;IAC3BC,OAAO,EAAElB,QAAQ,CAACkB,OAAO,IAAI,EAAE;IAC/BI,WAAW,EAAEtB,QAAQ,CAACsB,WAAW,IAAI,EAAE;IACvC9B,YAAY,EAAEW,mBAAmB;IACjCR,oBAAoB;IACpBU,gBAAgB;IAChBN,oBAAoB;IACpBL;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,aAAa,CAACsB,MAAM,EAAErB,GAAG,EAAE;EAChC,MAAM;IAAEE,IAAI,EAAEE,aAAa;IAAEkB;EAAM,CAAC,GAAGC,UAAU,CAACF,MAAM,EAAErB,GAAG,CAAC;EAC9D,IAAIsB,KAAK,KAAKV,SAAS,EAAE;IACrB,OAAO;MAAEV,IAAI,EAAEE;IAAc,CAAC;EAClC,CAAC,MACI;IACD,MAAM,CAACoB,gBAAgB,EAAE,GAAGP,SAAS,CAAC,GAAGK,KAAK,CAACG,KAAK,CAACrC,mBAAmB,CAAC;IACzE,MAAM,CAACsC,cAAc,EAAEX,QAAQ,CAAC,GAAGS,gBAAgB,CAACC,KAAK,CAACtC,YAAY,EAAE,CAAC,CAAC;IAC1E,IAAI,CAAC6B,OAAO,EAAEI,WAAW,CAAC,GAAGM,cAAc,CAACD,KAAK,CAACvC,iBAAiB,EAAE,CAAC,CAAC;IACvE,IAAIkC,WAAW,KAAKR,SAAS,EAAE;MAC3BQ,WAAW,GAAGJ,OAAO;MACrBA,OAAO,GAAGJ,SAAS;IACvB;IACA,IAAIQ,WAAW,KAAK,EAAE,EAAE;MACpBA,WAAW,GAAGR,SAAS;IAC3B;IACA,OAAO;MAAEV,IAAI,EAAEE,aAAa;MAAEY,OAAO;MAAEI,WAAW;MAAEL,QAAQ;MAAEE;IAAU,CAAC;EAC7E;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASN,gBAAgB,CAACU,MAAM,EAAErB,GAAG,EAAE;EACnC,MAAM;IAAEE,IAAI,EAAEK,WAAW;IAAEe;EAAM,CAAC,GAAGC,UAAU,CAACF,MAAM,EAAErB,GAAG,CAAC;EAC5D,IAAIsB,KAAK,KAAKV,SAAS,EAAE;IACrB,OAAO;MAAEL;IAAY,CAAC;EAC1B,CAAC,MACI;IACD,MAAM,CAACC,eAAe,EAAEE,mBAAmB,CAAC,GAAGY,KAAK,CAACG,KAAK,CAACtC,YAAY,CAAC;IACxE,OAAO;MAAEoB,WAAW;MAAEC,eAAe;MAAEE;IAAoB,CAAC;EAChE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASa,UAAU,CAACF,MAAM,EAAErB,GAAG,EAAE;EAC7B,IAAIA,GAAG,CAAC2B,MAAM,CAAC,CAAC,CAAC,KAAK1C,cAAc,EAAE;IAClC,OAAO;MAAEiB,IAAI,EAAEmB;IAAO,CAAC;EAC3B,CAAC,MACI;IACD,MAAMO,UAAU,GAAGC,cAAc,CAACR,MAAM,EAAErB,GAAG,CAAC;IAC9C,OAAO;MACHsB,KAAK,EAAED,MAAM,CAACS,SAAS,CAAC,CAAC,EAAEF,UAAU,CAAC;MACtC1B,IAAI,EAAEmB,MAAM,CAACS,SAAS,CAACF,UAAU,GAAG,CAAC;IACzC,CAAC;EACL;AACJ;AACA,SAASnB,sBAAsB,CAACsB,KAAK,EAAE;EACnC,OAAOA,KAAK,KAAK,CAAC,GAAG,IAAI,GAAI,MAAKA,KAAK,GAAG,CAAE,EAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,cAAc,CAACR,MAAM,EAAErB,GAAG,EAAE;EACjC,KAAK,IAAIgC,WAAW,GAAG,CAAC,EAAEC,QAAQ,GAAG,CAAC,EAAED,WAAW,GAAGX,MAAM,CAACf,MAAM,EAAE0B,WAAW,EAAE,EAAEC,QAAQ,EAAE,EAAE;IAC5F,IAAIjC,GAAG,CAACiC,QAAQ,CAAC,KAAK,IAAI,EAAE;MACxBA,QAAQ,EAAE;IACd,CAAC,MACI,IAAIZ,MAAM,CAACW,WAAW,CAAC,KAAK/C,cAAc,EAAE;MAC7C,OAAO+C,WAAW;IACtB;EACJ;EACA,MAAM,IAAIE,KAAK,CAAE,6CAA4ClC,GAAI,IAAG,CAAC;AACzE;AAEA,MAAMmC,uBAAuB,SAASD,KAAK,CAAC;EACxCE,WAAW,CAACC,aAAa,EAAE;IACvB,KAAK,CAAE,4BAA2BC,eAAe,CAACD,aAAa,CAAE,GAAE,CAAC;IACpE,IAAI,CAACA,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACE,IAAI,GAAG,yBAAyB;EACzC;AACJ;AACA,SAASC,yBAAyB,CAACC,CAAC,EAAE;EAClC,OAAOA,CAAC,CAACF,IAAI,KAAK,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,WAAW,CAACC,YAAY,EAAErD,YAAY,EAAEK,aAAa,EAAE;EAC5D,MAAMiD,OAAO,GAAGvD,YAAY,CAACC,YAAY,EAAEK,aAAa,CAAC;EACzD;EACA,IAAIkD,WAAW,GAAGF,YAAY,CAACC,OAAO,CAACzB,EAAE,CAAC;EAC1C;EACA,IAAIyB,OAAO,CAAC3B,SAAS,KAAKL,SAAS,EAAE;IACjC,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuC,OAAO,CAAC3B,SAAS,CAACX,MAAM,IAAIuC,WAAW,KAAKjC,SAAS,EAAEP,CAAC,EAAE,EAAE;MAC5EwC,WAAW,GAAGF,YAAY,CAACC,OAAO,CAAC3B,SAAS,CAACZ,CAAC,CAAC,CAAC;IACpD;EACJ;EACA,IAAIwC,WAAW,KAAKjC,SAAS,EAAE;IAC3B,MAAM,IAAIuB,uBAAuB,CAACS,OAAO,CAAC;EAC9C;EACA,OAAO,CACHC,WAAW,CAACvD,YAAY,EAAEuD,WAAW,CAAC1C,gBAAgB,CAAC2C,GAAG,CAACC,WAAW,IAAI;IACtE,IAAIH,OAAO,CAACjD,aAAa,CAACqD,cAAc,CAACD,WAAW,CAAC,EAAE;MACnD,OAAOH,OAAO,CAACjD,aAAa,CAACoD,WAAW,CAAC;IAC7C,CAAC,MACI;MACD,MAAM,IAAIb,KAAK,CAAE,sFAAqFI,eAAe,CAACM,OAAO,CAAE,KAAI,GAC9H,oDAAmDG,WAAY,wCAAuC,CAAC;IAChH;EACJ,CAAC,CAAC,CACL;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,gBAAgB,CAAC7C,aAAa,EAAE;EACrC,MAAM8C,KAAK,GAAG9C,aAAa,CAACqB,KAAK,CAAC,aAAa,CAAC;EAChD,MAAMnC,YAAY,GAAG,CAAC4D,KAAK,CAAC,CAAC,CAAC,CAAC;EAC/B,MAAM/C,gBAAgB,GAAG,EAAE;EAC3B,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6C,KAAK,CAAC5C,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;IAC1CF,gBAAgB,CAACU,IAAI,CAACqC,KAAK,CAAC7C,CAAC,CAAC,CAAC;IAC/Bf,YAAY,CAACuB,IAAI,CAAE,GAAEqC,KAAK,CAAC7C,CAAC,GAAG,CAAC,CAAE,EAAC,CAAC;EACxC;EACA,MAAM8C,eAAe,GAAG7D,YAAY,CAACwD,GAAG,CAACM,IAAI,IAAIA,IAAI,CAACzB,MAAM,CAAC,CAAC,CAAC,KAAK1C,cAAc,GAAG,IAAI,GAAGmE,IAAI,GAAGA,IAAI,CAAC;EACxG,OAAO;IACHlD,IAAI,EAAEE,aAAa;IACnBd,YAAY,EAAE+D,kBAAkB,CAAC/D,YAAY,EAAE6D,eAAe,CAAC;IAC/DhD;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmD,qBAAqB,CAAChE,YAAY,EAAEa,gBAAgB,GAAG,EAAE,EAAE;EAChE,IAAIC,aAAa,GAAGd,YAAY,CAAC,CAAC,CAAC;EACnC,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,gBAAgB,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IAC9CD,aAAa,IAAK,KAAID,gBAAgB,CAACE,CAAC,CAAE,IAAGf,YAAY,CAACe,CAAC,GAAG,CAAC,CAAE,EAAC;EACtE;EACA,OAAO;IACHH,IAAI,EAAEE,aAAa;IACnBd,YAAY,EAAE+D,kBAAkB,CAAC/D,YAAY,EAAEA,YAAY,CAAC;IAC5Da;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkD,kBAAkB,CAAChC,MAAM,EAAErB,GAAG,EAAE;EACrCuD,MAAM,CAACC,cAAc,CAACnC,MAAM,EAAE,KAAK,EAAE;IAAEoC,KAAK,EAAEzD;EAAI,CAAC,CAAC;EACpD,OAAOqB,MAAM;AACjB;AACA,SAASiB,eAAe,CAACM,OAAO,EAAE;EAC9B,MAAMc,aAAa,GAAGd,OAAO,CAAC5B,OAAO,IAAK,OAAM4B,OAAO,CAAC5B,OAAQ,GAAE;EAClE,MAAM2C,MAAM,GAAGf,OAAO,CAAC3B,SAAS,IAAI2B,OAAO,CAAC3B,SAAS,CAACX,MAAM,GAAG,CAAC,GAC3D,KAAIsC,OAAO,CAAC3B,SAAS,CAAC6B,GAAG,CAACc,CAAC,IAAK,IAAGA,CAAE,GAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAE,GAAE,GACvD,EAAE;EACN,OAAQ,IAAGjB,OAAO,CAACzB,EAAG,IAAGwC,MAAO,MAAKf,OAAO,CAAC1C,IAAK,IAAGwD,aAAc,GAAE;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,gBAAgB,CAACnB,YAAY,EAAE;EACpC;EACA,IAAI,CAACoB,SAAS,CAACC,SAAS,EAAE;IACtBD,SAAS,CAACC,SAAS,GAAGA,SAAS;EACnC;EACA,IAAI,CAACD,SAAS,CAACE,YAAY,EAAE;IACzBF,SAAS,CAACE,YAAY,GAAG,CAAC,CAAC;EAC/B;EACAV,MAAM,CAACW,IAAI,CAACvB,YAAY,CAAC,CAACwB,OAAO,CAACC,GAAG,IAAI;IACrCL,SAAS,CAACE,YAAY,CAACG,GAAG,CAAC,GAAGnB,gBAAgB,CAACN,YAAY,CAACyB,GAAG,CAAC,CAAC;EACrE,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,iBAAiB,GAAG;EACzBN,SAAS,CAACC,SAAS,GAAGpD,SAAS;EAC/BmD,SAAS,CAACE,YAAY,GAAG,CAAC,CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,SAAS,CAAC1E,YAAY,EAAEK,aAAa,EAAE;EAC5C,IAAI;IACA,OAAO+C,WAAW,CAACqB,SAAS,CAACE,YAAY,EAAE3E,YAAY,EAAEK,aAAa,CAAC;EAC3E,CAAC,CACD,OAAO8C,CAAC,EAAE;IACN6B,OAAO,CAACC,IAAI,CAAC9B,CAAC,CAACG,OAAO,CAAC;IACvB,OAAO,CAACtD,YAAY,EAAEK,aAAa,CAAC;EACxC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM6E,OAAO,GAAK,eAAe,CAAC,MAAO,OAAOC,UAAU,KAAK,WAAW,IAAIA,UAAU,IACnF,OAAOC,MAAM,KAAK,WAAW,IAAIA,MAAO,IAAK,OAAOC,MAAM,KAAK,WAAW,IAAIA,MAAO,IACrF,OAAOC,IAAI,KAAK,WAAW,IAAI,OAAOC,iBAAiB,KAAK,WAAW,IACpED,IAAI,YAAYC,iBAAiB,IAAID,IAAK,GAAI;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,WAAW,GAAG,UAAUxF,YAAY,EAAE,GAAGC,WAAW,EAAE;EACxD,IAAIuF,WAAW,CAACd,SAAS,EAAE;IACvB;IACA,MAAMnB,WAAW,GAAGiC,WAAW,CAACd,SAAS,CAAC1E,YAAY,EAAEC,WAAW,CAAC;IACpED,YAAY,GAAGuD,WAAW,CAAC,CAAC,CAAC;IAC7BtD,WAAW,GAAGsD,WAAW,CAAC,CAAC,CAAC;EAChC;EACA,IAAID,OAAO,GAAGmC,UAAU,CAACzF,YAAY,CAAC,CAAC,CAAC,EAAEA,YAAY,CAACU,GAAG,CAAC,CAAC,CAAC,CAAC;EAC9D,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,YAAY,CAACgB,MAAM,EAAED,CAAC,EAAE,EAAE;IAC1CuC,OAAO,IAAIrD,WAAW,CAACc,CAAC,GAAG,CAAC,CAAC,GAAG0E,UAAU,CAACzF,YAAY,CAACe,CAAC,CAAC,EAAEf,YAAY,CAACU,GAAG,CAACK,CAAC,CAAC,CAAC;EACpF;EACA,OAAOuC,OAAO;AAClB,CAAC;AACD,MAAMoC,YAAY,GAAG,GAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,UAAU,CAACxE,WAAW,EAAE0E,cAAc,EAAE;EAC7C,OAAOA,cAAc,CAACtD,MAAM,CAAC,CAAC,CAAC,KAAKqD,YAAY,GAC5CzE,WAAW,CAACuB,SAAS,CAACD,cAAc,CAACtB,WAAW,EAAE0E,cAAc,CAAC,GAAG,CAAC,CAAC,GACtE1E,WAAW;AACnB;;AAEA;;AAEA;;AAEA;;AAEA,SAAS8D,iBAAiB,EAAEP,gBAAgB,EAAEgB,WAAW,IAAII,UAAU,EAAE/C,uBAAuB,IAAIgD,wBAAwB,EAAEX,OAAO,IAAIY,QAAQ,EAAEvD,cAAc,IAAIwD,eAAe,EAAE7C,yBAAyB,IAAI8C,0BAA0B,EAAEhC,qBAAqB,IAAIiC,sBAAsB,EAAElC,kBAAkB,IAAImC,mBAAmB,EAAEnG,YAAY,IAAIoG,aAAa,EAAE1F,aAAa,IAAI2F,cAAc,EAAEzC,gBAAgB,IAAI0C,iBAAiB,EAAEpE,UAAU,IAAIqE,WAAW,EAAElD,WAAW,IAAImD,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}